// драйвер фильтра для компьютерной мыши(UMDF) [пользовательский тип]

#include "Wdf.h"
#include"Driver.h"//библиотеки для UMDF

//Sources

UMDF_Version = 1
UMDF_MINOR_VERSION = 5
TARGETNAME=WUDFOsrUsbFx2
TARGETTYPE=DYNLINK
USE_MSVCRT=1






//создание объекта обратного вызова дравера UMDL

HRESULT CMyDriver::CreateInstance(
	_out PCMyDriver *Driver
	)

{
	PCMyDriver driver;
	HRESULT hr;
	//выделяем объект обратного вызова.
	driver = new CMyDrive();
	if (NULL == driver)
	{
		return E_OUTOFMEMORY;
	}

	//Инициализируем объект обратного вызова.
	hr = driver->Initialize();
	if (SUCCEEDED(hr))
   {

		//Возвращение указателя на только что созданный объект
		*Driver = driver;
   }

else 
    {
	//освобождение ссылки на объект драйвера
	driver->Release();
    }
return hr;

}


//Создание объекта устройства

FxDeviceInit->SetLockingConstraint(WdfDeviceLevel);
{
	IUnknown *unknown = device->QueryIUnknown();
	hr = FxDriver->CreateDevice(FxDeviceInit, unknown, &fxDevice)
		unknown->Release();
}

if (S_OK == hr) {
	fxDevice->Release();

}


//Инициализация Plug and Play в драйвере фильтра UMDF

HRESULT CMyDevice::Initialize(
	_in IWDFDriver *FxDriver,
	_in IWDFDeviceInitialize *FxDeviceInit)
{
	IWDFDevice *fxDevice;
	HRESULT hr;
	FxDeviceInit->SetLockingConstraint(None);
	FxDeviceInit->SetFilter();
	FxDeviceInit->SetPowerPolicyOwnership(FALSE);
	{
		IUnknows *unknown = this->QueryIUnknown();
		hr = FxDriver->CreateDevice(FxDeviceInit, unknown, &fxDevice);
		unknown->Release();
	}
	if (SUCCEEDED(hr)){
		m_FxDevice = fxDevice;
		fxDevice->Release();
	}
	return hr;
}



// Создание запроса ввода - вывода

HRESULT hr = S_OK;
IWDFIoRequest *pWdfRequest = NULL;
IWDFDriver * FxDriver = NULL;
hr = m_FxDevice->CreateRequst( NULL, NULL, & pWdfRequest )
